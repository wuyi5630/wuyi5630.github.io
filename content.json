[{"title":"Hello World","date":"2017-03-21T04:22:47.438Z","path":"2017/03/21/spring/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"","date":"2017-03-03T08:12:30.007Z","path":"2017/03/03/pinpoint源码分析系列1.启动加载插件分析/","text":"pinpoint 源码分析系列 Agent-1.启动加载插件分析Agent加载类采用了JDK的Instrumentation技术。 程序的入口为：com.navercorp.pinpoint.bootstrap.PinpointBootStrap 入口方法自然而然的是premain方法： 获取环境变量 1final ClassPathResolver classPathResolver = new AgentDirBaseClassPathResolver(); 获取agent包的路径，加载到JDK的load中。 12BootstrapJarFile bootstrapJarFile = classPathResolver.getBootstrapJarFile();appendToBootstrapClassLoader(instrumentation, bootstrapJarFile); 最关键的一句就是bootStrap.start() 此方法调用`PinpointStarter`的`start()`方法，此方法首先获取获取环境变量中配置的`agentId`和`applicationName`，并且校验。 PinpointStarter start 方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960boolean start() &#123;/** *采用Java的ServiceLoader类获取TraceMetadata、 ServiceType， 通过TraceMetadata获取注解信息，读取配置信息。 本方法最核心的就是创建agent，启动加载所有的核心也都在这个 Agent类中， 此类默认是DefaultAgent对象，通过反射机制创建的。*/final IdValidator idValidator = new IdValidator();final String agentId = idValidator.getAgentId(); //获取获取环境变量中配置的agentIdif (agentId == null) &#123; return false;&#125;final String applicationName = idValidator.getApplicationName(); //获取获取环境变量中配置的applicationNameif (applicationName == null) &#123; return false;&#125;//载入所有plugin的jar URL[] pluginJars = classPathResolver.resolvePlugins(); // TODO using PLogger instead of CommonLogger CommonLoggerFactory loggerFactory = StdoutCommonLoggerFactory.INSTANCE; TraceMetadataLoaderService typeLoaderService = new DefaultTraceMetadataLoaderService(pluginJars, loggerFactory); ServiceTypeRegistryService serviceTypeRegistryService = new DefaultServiceTypeRegistryService(typeLoaderService, loggerFactory); AnnotationKeyRegistryService annotationKeyRegistryService = new DefaultAnnotationKeyRegistryService(typeLoaderService, loggerFactory); String configPath = getConfigPath(classPathResolver); if (configPath == null) &#123; return false; &#125; // set the path of log file as a system property saveLogFilePath(classPathResolver); savePinpointVersion(); try &#123; // Is it right to load the configuration in the bootstrap? ProfilerConfig profilerConfig = DefaultProfilerConfig.load(configPath); // this is the library list that must be loaded List&lt;URL&gt; libUrlList = resolveLib(classPathResolver); AgentClassLoader agentClassLoader = new AgentClassLoader(libUrlList.toArray(new URL[libUrlList.size()])); final String bootClass = getBootClass(); agentClassLoader.setBootClass(bootClass); logger.info(\"pinpoint agent [\" + bootClass + \"] starting...\"); AgentOption option = createAgentOption(agentId, applicationName, profilerConfig, instrumentation, pluginJars, bootstrapJarFile, serviceTypeRegistryService, annotationKeyRegistryService); Agent pinpointAgent = agentClassLoader.boot(option);//==通过反射机制创建的== pinpointAgent.start(); //创建DefaultAgent启动加载所有核心 registerShutdownHook(pinpointAgent); logger.info(\"pinpoint agent started normally.\"); &#125; catch (Exception e) &#123; // unexpected exception that did not be checked above logger.warn(ProductInfo.NAME + \" start failed.\", e); return false; &#125; return true;&#125; DefaultAgent 所有核心操作都在构造方法中&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798 public DefaultAgent(AgentOption agentOption, final InterceptorRegistryBinder interceptorRegistryBinder) &#123; if (agentOption == null) &#123; throw new NullPointerException(\"agentOption must not be null\"); &#125; if (agentOption.getInstrumentation() == null) &#123; throw new NullPointerException(\"instrumentation must not be null\"); &#125; if (agentOption.getProfilerConfig() == null) &#123; throw new NullPointerException(\"profilerConfig must not be null\"); &#125; if (agentOption.getServiceTypeRegistryService() == null) &#123; throw new NullPointerException(\"serviceTypeRegistryService must not be null\"); &#125; if (interceptorRegistryBinder == null) &#123; throw new NullPointerException(\"interceptorRegistryBinder must not be null\"); &#125; logger.info(\"AgentOption:&#123;&#125;\", agentOption); this.binder = new Slf4jLoggerBinder(); bindPLoggerFactory(this.binder); this.interceptorRegistryBinder = interceptorRegistryBinder; interceptorRegistryBinder.bind(); this.serviceTypeRegistryService = agentOption.getServiceTypeRegistryService(); dumpSystemProperties(); dumpConfig(agentOption.getProfilerConfig()); changeStatus(AgentStatus.INITIALIZING); this.profilerConfig = agentOption.getProfilerConfig(); this.instrumentation = agentOption.getInstrumentation(); this.agentOption = agentOption; this.classPool = createInstrumentEngine(agentOption, interceptorRegistryBinder); if (logger.isInfoEnabled()) &#123; logger.info(\"DefaultAgent classLoader:&#123;&#125;\", this.getClass().getClassLoader()); &#125; pluginContexts = loadPlugins(agentOption); //加载插件 this.classFileTransformer = new ClassFileTransformerDispatcher(this, pluginContexts); this.dynamicTransformService = new DynamicTransformService(instrumentation, classFileTransformer); ClassFileTransformer wrappedTransformer = wrapClassFileTransformer(classFileTransformer); instrumentation.addTransformer(wrappedTransformer, true); String applicationServerTypeString = profilerConfig.getApplicationServerType(); ServiceType applicationServerType = this.serviceTypeRegistryService.findServiceTypeByName(applicationServerTypeString); final ApplicationServerTypeResolver typeResolver = new ApplicationServerTypeResolver(pluginContexts, applicationServerType, profilerConfig.getApplicationTypeDetectOrder()); final AgentInformationFactory agentInformationFactory = new AgentInformationFactory(agentOption.getAgentId(), agentOption.getApplicationName()); //加载 agent的信息 this.agentInformation = agentInformationFactory.createAgentInformation(typeResolver.resolve()); logger.info(\"agentInformation:&#123;&#125;\", agentInformation); CommandDispatcher commandDispatcher = new CommandDispatcher(); //-- TCP数据发送者 this.tcpDataSender = createTcpDataSender(commandDispatcher); this.serverMetaDataHolder = createServerMetaDataHolder(); //-- span数据发送模块的初始化，参数是 //【端口，线程名，写入队列的大小默认1024 * 5，设置超时时间默认1000 * 3， 发送缓冲的大小默认1024 * 64 * 16】 //-- 这些值都是来自pinpoint.config中默认值在DefaultProfilerConfig.java文件中。 this.spanDataSender = createUdpSpanDataSender(this.profilerConfig.getCollectorSpanServerPort(), \"Pinpoint-UdpSpanDataExecutor\", this.profilerConfig.getSpanDataSenderWriteQueueSize(), this.profilerConfig.getSpanDataSenderSocketTimeout(), this.profilerConfig.getSpanDataSenderSocketSendBufferSize()); //-- AgentStatMonitor数据发送模块模块的初始化 this.statDataSender = createUdpStatDataSender(this.profilerConfig.getCollectorStatServerPort(), \"Pinpoint-UdpStatDataExecutor\", this.profilerConfig.getStatDataSenderWriteQueueSize(), this.profilerConfig.getStatDataSenderSocketTimeout(), this.profilerConfig.getStatDataSenderSocketSendBufferSize()); this.traceContext = createTraceContext(); addCommandService(commandDispatcher, traceContext); AgentStatCollectorFactory agentStatCollectorFactory = new AgentStatCollectorFactory(this.traceContext); JvmInformationFactory jvmInformationFactory = new JvmInformationFactory(agentStatCollectorFactory.getGarbageCollector()); //-- 真实发送AgentInfo数据的代码 ,TCP端口发送，而且是一个定时发送 //agentInfo数据发送者this.agentInfoSender .start() ，就能创建一个周期性发送agentInfo！采用的是TCP this.agentInfoSender = new AgentInfoSender.Builder(tcpDataSender, this.agentInformation, jvmInformationFactory.createJvmInformation()).sendInterval(profilerConfig.getAgentInfoSendRetryInterval()).build(); this.serverMetaDataHolder.addListener(this.agentInfoSender); this.agentStatMonitor = new AgentStatMonitor(this.statDataSender, this.agentInformation.getAgentId(), this.agentInformation.getStartTime(), agentStatCollectorFactory); InterceptorInvokerHelper.setPropagateException(profilerConfig.isPropagateInterceptorException()); &#125; 追踪方法即到具体插件的的加载中 12345678910111213141516171819202122232425262728293031323334353637ProfilerPluginLoader.java public List&lt;DefaultProfilerPluginContext&gt; load(URL[] pluginJars) &#123; List&lt;DefaultProfilerPluginContext&gt; pluginContexts = new ArrayList&lt;DefaultProfilerPluginContext&gt;(pluginJars.length); List&lt;String&gt; disabled = agent.getProfilerConfig().getDisabledPlugins(); for (URL jar : pluginJars) &#123; final JarFile pluginJarFile = createJarFile(jar); final List&lt;String&gt; pluginPackageList = getPluginPackage(pluginJarFile); final ClassNameFilter pluginFilterChain = createPluginFilterChain(pluginPackageList); final List&lt;ProfilerPlugin&gt; plugins = PluginLoader.load(ProfilerPlugin.class, new URL[] &#123; jar &#125;); for (ProfilerPlugin plugin : plugins) &#123; if (disabled.contains(plugin.getClass().getName())) &#123; logger.info(\"Skip disabled plugin: &#123;&#125;\", plugin.getClass().getName()); continue; &#125; if (logger.isInfoEnabled()) &#123; logger.info(\"&#123;&#125; Plugin &#123;&#125;:&#123;&#125;\", plugin.getClass(), PluginConfig.PINPOINT_PLUGIN_PACKAGE, pluginPackageList); &#125; logger.info(\"Loading plugin:&#123;&#125; pluginPackage:&#123;&#125;\", plugin.getClass().getName(), plugin); PluginConfig pluginConfig = new PluginConfig(jar, plugin, agent.getInstrumentation(), agent.getClassPool(), agent.getBootstrapJarPaths(), pluginFilterChain); //重点------开始 final DefaultProfilerPluginContext context = setupPlugin(pluginConfig); //重点------结束 pluginContexts.add(context); &#125; &#125; return pluginContexts; &#125; Load方法遍历加载每个plugin中的插件。其实是根据ServiceLoader加载的。 12345678910111213141516171819 private DefaultProfilerPluginContext setupPlugin(PluginConfig pluginConfig) &#123; final ClassInjector classInjector = new JarProfilerPluginClassInjector(pluginConfig); final DefaultProfilerPluginContext context = new DefaultProfilerPluginContext(agent, classInjector); final GuardProfilerPluginContext guardPluginContext = new GuardProfilerPluginContext(context); final GuardInstrumentContext guardInstrumentContext = preparePlugin(pluginConfig.getPlugin(), context); try &#123; // WARN external plugin api final ProfilerPlugin plugin = pluginConfig.getPlugin(); if (logger.isInfoEnabled()) &#123; logger.info(\"&#123;&#125; Plugin setup\", plugin.getClass().getName()); &#125; plugin.setup(guardPluginContext); &#125; finally &#123; guardPluginContext.close(); guardInstrumentContext.close(); &#125; return context;&#125; 其中在preparePlugin方法中，可以看到自定义插件中的构造方法中的参加，就是在这里注入的。而plugin.setup(guardPluginContext)方法就是自定义插件中的需要实现的方法，其中自定义插件中的transformTemplate.transform就是调用的DefaultProfilerPluginContext.addClassFileTransformer.也就是本方法的第二行。 具体加载类文件，然后进行二进制操作的是instrumentation.addTransformer(wrappedTransformer, true);//ClassFileTransformerDispatcher,在此处instrumentation是ClassFileTransformerDispatcher的对象，跟踪代码到ClassFileTransformerDispatcher.transform0方法中。 123DefaultAgent.java l187 ClassFileTransformer wrappedTransformer = wrapClassFileTransformer(classFileTransformer); instrumentation.addTransformer(wrappedTransformer, true); 而此处的transformer是MatchableClassFileTransformerGuardDelegate的对象，跟踪代码得到自定义插件中拦截方法的具体内容。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778ClassFileTransformerDispatcher.java @Overridepublic byte[] transform(ClassLoader classLoader, String jvmClassName, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classFileBuffer) throws IllegalClassFormatException &#123; if (!pinpointClassFilter.accept(classLoader, jvmClassName, classBeingRedefined, protectionDomain, classFileBuffer)) &#123; return null; &#125; final ClassFileTransformer dynamicTransformer = dynamicTransformerRegistry.getTransformer(classLoader, jvmClassName); if (dynamicTransformer != null) &#123; return transform0(classLoader, jvmClassName, classBeingRedefined, protectionDomain, classFileBuffer, dynamicTransformer); &#125; if (!unmodifiableFilter.accept(classLoader, jvmClassName, classBeingRedefined, protectionDomain, classFileBuffer)) &#123; return null; &#125; ClassFileTransformer transformer = this.transformerRegistry.findTransformer(jvmClassName); if (transformer == null) &#123; // For debug // TODO What if a modifier is duplicated? if (this.debugTargetFilter.filter(jvmClassName)) &#123; // Added to see if call stack view is OK on a test machine. transformer = debugTransformer; &#125; else &#123; return null; &#125; &#125; return transform0(classLoader, jvmClassName, classBeingRedefined, protectionDomain, classFileBuffer, transformer);&#125;private byte[] transform0(ClassLoader classLoader, String jvmClassName, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classFileBuffer, ClassFileTransformer transformer) &#123; final String javaClassName = JavaAssistUtils.jvmNameToJavaName(jvmClassName); if (isDebug) &#123; if (classBeingRedefined == null) &#123; logger.debug(\"[transform] classLoader:&#123;&#125; className:&#123;&#125; transformer:&#123;&#125;\", classLoader, javaClassName, transformer.getClass().getName()); &#125; else &#123; logger.debug(\"[retransform] classLoader:&#123;&#125; className:&#123;&#125; transformer:&#123;&#125;\", classLoader, javaClassName, transformer.getClass().getName()); &#125; &#125; try &#123; final Thread thread = Thread.currentThread(); final ClassLoader before = getContextClassLoader(thread); thread.setContextClassLoader(this.agentClassLoader); try &#123; return transformer.transform(classLoader, javaClassName, classBeingRedefined, protectionDomain, classFileBuffer); &#125; finally &#123; // The context class loader have to be recovered even if it was null. thread.setContextClassLoader(before); &#125; &#125; catch (Throwable e) &#123; logger.error(\"Transformer:&#123;&#125; threw an exception. cl:&#123;&#125; ctxCl:&#123;&#125; agentCl:&#123;&#125; Cause:&#123;&#125;\", transformer.getClass().getName(), classLoader, Thread.currentThread().getContextClassLoader(), agentClassLoader, e.getMessage(), e); return null; &#125;&#125;MatchableClassFileTransformerGuardDelegate.java @Overridepublic byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException &#123; if (className == null) &#123; throw new NullPointerException(\"className must not be null\"); &#125; final GuardInstrumentor guard = new GuardInstrumentor(this.instrumentContext); try &#123; // WARN external plugin api return transformCallback.doInTransform(guard, loader, className, classBeingRedefined, protectionDomain, classfileBuffer); &#125; catch (InstrumentException e) &#123; throw new PinpointException(e); &#125; finally &#123; guard.close(); &#125;&#125;","tags":[]},{"title":"Hello World","date":"2017-02-03T04:42:09.377Z","path":"2017/02/03/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"pinpoint的Collector-UDP部分源码分析","date":"2017-01-20T00:55:29.000Z","path":"2017/01/20/pinpoint的Collector-UDP源码分析/","text":"pinpoint的Collector-UDP部分源码分析接上一篇文章，接下来对Collector中的UDP部分进行源码解析。最重要的类是UDPReceiver，在applicationContext-collector.xml中，udpSpanReceiver，udpStatReceiver注入到UDPReceiver。 注： constructor-arg index=1 指的是按照构造方法的参数列表顺序 udp部分主要是传输分布式服务调用的信息与agent状态的信息。 知识备注： 从Java EE 5规范开始，Servlet中增加了两个影响Servlet生命周期的注解（Annotion):@PostConstruct和@PreDestroy。这两个注解被用来修饰一个非静态的void()方法 。写法有如下两种方式：12@PostConstructPublic void someMethod() &#123;&#125; 或者1public @PostConstruct void someMethod()&#123;&#125; 被@PostConstruct修饰的方法会在服务器加载Servle的时候运行，并且只会被服务器执行一次。PostConstruct在构造函数之后执行,init()方法之前执行。PreDestroy（）方法在destroy()方法执行执行之后执行。 UDPReceiver是对DataReceiver的实现，首先执行UDPReceiver的构造函数，并调用被@PostConstruct修饰start()方法。start()方法中先后调用afterPropertiesSet(),bindSocket（），receive()方法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137@PostConstruct @Override public void start() &#123; logger.info(\"&#123;&#125; start.\", receiverName); afterPropertiesSet(); final DatagramSocket socket = this.socket; if (socket == null) &#123; throw new IllegalStateException(\"socket is null.\"); &#125; bindSocket(socket, bindAddress, port); //绑定socket，socket通过执行UDPReceiver的构造函数createSocket方法进行创建， //参数receiveBufferSize，以及timeout时间。 logger.info(\"UDP Packet reader:&#123;&#125; started.\", ioThreadSize); for (int i = 0; i &lt; ioThreadSize; i++) &#123; io.execute(new Runnable() &#123; @Override public void run() &#123; receive(socket); &#125; &#125;); &#125; &#125; private void receive(final DatagramSocket socket) &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"start ioThread localAddress:&#123;&#125;, IoThread:&#123;&#125;\", this.socket.getLocalAddress(), Thread.currentThread().getName()); &#125; final SocketAddress localSocketAddress = socket.getLocalSocketAddress(); final boolean debugEnabled = logger.isDebugEnabled(); // need shutdown logic while (state.get()) &#123; PooledObject&lt;DatagramPacket&gt; pooledPacket = read0(socket); if (pooledPacket == null) &#123; continue; &#125; final DatagramPacket packet = pooledPacket.getObject(); if (packet.getLength() == 0) &#123; if (debugEnabled) &#123; logger.debug(\"length is 0 ip:&#123;&#125;, port:&#123;&#125;\", packet.getAddress(), packet.getPort()); &#125; return; &#125; try &#123; Runnable dispatchTask = wrapDispatchTask(pooledPacket); worker.execute(dispatchTask); &#125; catch (RejectedExecutionException ree) &#123; handleRejectedExecutionException(ree); &#125; &#125; if (logger.isInfoEnabled()) &#123; logger.info(\"stop ioThread localAddress:&#123;&#125;, IoThread:&#123;&#125;\", localSocketAddress, Thread.currentThread().getName()); &#125; &#125; public void afterPropertiesSet() &#123; Assert.notNull(metricRegistry, \"metricRegistry must not be null\"); Assert.notNull(packetHandlerFactory, \"packetHandlerFactory must not be null\"); this.worker = createWorker(workerOption, receiverName + \"-Worker\"); if (workerOption.isEnableCollectMetric()) &#123; this.worker = new MonitoredExecutorService(worker, metricRegistry, receiverName + \"-Worker\"); &#125; final int packetPoolSize = getPacketPoolSize(workerOption); this.datagramPacketPool = new DefaultObjectPool&lt;&gt;(new DatagramPacketFactory(), packetPoolSize); this.io = (ThreadPoolExecutor) Executors.newCachedThreadPool(new PinpointThreadFactory(receiverName + \"-Io\", true)); &#125; private Runnable wrapDispatchTask(final PooledObject&lt;DatagramPacket&gt; pooledPacket) &#123; final Runnable lazyExecution = new Runnable() &#123; @Override public void run() &#123; PacketHandler&lt;DatagramPacket&gt; dispatchPacket = packetHandlerFactory.createPacketHandler(); PooledPacketWrap pooledPacketWrap = new PooledPacketWrap(dispatchPacket, pooledPacket); Runnable execution = pooledPacketWrap; execution.run(); &#125; &#125;; return lazyExecution; &#125; private PooledObject&lt;DatagramPacket&gt; read0(final DatagramSocket socket) &#123; boolean success = false; PooledObject&lt;DatagramPacket&gt; pooledObject = datagramPacketPool.getObject(); if (pooledObject == null) &#123; logger.error(\"datagramPacketPool is empty\"); return null; &#125; DatagramPacket packet = pooledObject.getObject(); try &#123; try &#123; socket.receive(packet); success = true; &#125; catch (SocketTimeoutException e) &#123; return null; &#125; if (logger.isDebugEnabled()) &#123; logger.debug(\"DatagramPacket SocketAddress:&#123;&#125; read size:&#123;&#125;\", packet.getSocketAddress(), packet.getLength()); if (logger.isTraceEnabled()) &#123; // use trace as packet dump may be large logger.trace(\"dump packet:&#123;&#125;\", PacketUtils.dumpDatagramPacket(packet)); &#125; &#125; &#125; catch (IOException e) &#123; if (!state.get()) &#123; // shutdown &#125; else &#123; logger.error(\"IoError, Caused:\", e.getMessage(), e); &#125; return null; &#125; finally &#123; if (!success) &#123; pooledObject.returnObject(); &#125; &#125; return pooledObject; &#125; private DatagramSocket createSocket(int receiveBufferSize) &#123; try &#123; DatagramSocket socket = new DatagramSocket(null); socket.setReceiveBufferSize(receiveBufferSize); if (logger.isWarnEnabled()) &#123; final int checkReceiveBufferSize = socket.getReceiveBufferSize(); if (receiveBufferSize != checkReceiveBufferSize) &#123; logger.warn(\"DatagramSocket.setReceiveBufferSize() error. &#123;&#125;!=&#123;&#125;\", receiveBufferSize, checkReceiveBufferSize); &#125; &#125; socket.setSoTimeout(1000 * 5); return socket; &#125; catch (SocketException ex) &#123; throw new RuntimeException(\"Socket create Fail. Caused:\" + ex.getMessage(), ex); &#125; &#125;","tags":[]}]